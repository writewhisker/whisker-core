-- spec/script/lexer/scanner_spec.lua
-- Unit tests for the character-level scanner

describe("Scanner", function()
  local scanner_module

  before_each(function()
    package.loaded["whisker.script.lexer.scanner"] = nil
    package.loaded["whisker.script.source"] = nil
    scanner_module = require("whisker.script.lexer.scanner")
  end)

  describe("Scanner.new()", function()
    it("should create scanner with source", function()
      local s = scanner_module.Scanner.new("hello")
      assert.is_table(s)
      assert.are.equal("hello", s.source)
    end)

    it("should initialize at position (1,1,0)", function()
      local s = scanner_module.Scanner.new("test")
      local pos = s:get_position()
      assert.are.equal(1, pos.line)
      assert.are.equal(1, pos.column)
      assert.are.equal(0, pos.offset)
    end)

    it("should handle empty source", function()
      local s = scanner_module.Scanner.new("")
      assert.is_true(s:at_end())
    end)

    it("should handle nil source", function()
      local s = scanner_module.Scanner.new(nil)
      assert.are.equal("", s.source)
      assert.is_true(s:at_end())
    end)
  end)

  describe("peek()", function()
    it("should return current character", function()
      local s = scanner_module.Scanner.new("abc")
      assert.are.equal("a", s:peek())
    end)

    it("should return nil at end", function()
      local s = scanner_module.Scanner.new("")
      assert.is_nil(s:peek())
    end)

    it("should return character at offset", function()
      local s = scanner_module.Scanner.new("hello")
      assert.are.equal("h", s:peek(0))
      assert.are.equal("e", s:peek(1))
      assert.are.equal("l", s:peek(2))
      assert.are.equal("l", s:peek(3))
      assert.are.equal("o", s:peek(4))
    end)

    it("should return nil for offset past end", function()
      local s = scanner_module.Scanner.new("hi")
      assert.is_nil(s:peek(5))
    end)

    it("should not advance position", function()
      local s = scanner_module.Scanner.new("test")
      s:peek()
      s:peek(2)
      local pos = s:get_position()
      assert.are.equal(0, pos.offset)
    end)
  end)

  describe("current()", function()
    it("should return same as peek(0)", function()
      local s = scanner_module.Scanner.new("xyz")
      assert.are.equal(s:peek(0), s:current())
    end)
  end)

  describe("advance()", function()
    it("should return current character", function()
      local s = scanner_module.Scanner.new("abc")
      assert.are.equal("a", s:advance())
    end)

    it("should advance position", function()
      local s = scanner_module.Scanner.new("abc")
      s:advance()
      assert.are.equal("b", s:peek())
    end)

    it("should update offset", function()
      local s = scanner_module.Scanner.new("test")
      s:advance()
      local pos = s:get_position()
      assert.are.equal(1, pos.offset)
    end)

    it("should return nil at end", function()
      local s = scanner_module.Scanner.new("x")
      s:advance()
      assert.is_nil(s:advance())
    end)

    it("should track column through regular characters", function()
      local s = scanner_module.Scanner.new("abc")
      s:advance()
      s:advance()
      local pos = s:get_position()
      assert.are.equal(3, pos.column)
    end)

    it("should track line through newlines", function()
      local s = scanner_module.Scanner.new("a\nb")
      s:advance()  -- 'a'
      s:advance()  -- '\n'
      local pos = s:get_position()
      assert.are.equal(2, pos.line)
      assert.are.equal(1, pos.column)
    end)

    it("should handle multiple lines", function()
      local s = scanner_module.Scanner.new("a\nb\nc")
      s:advance()  -- a
      s:advance()  -- \n
      s:advance()  -- b
      s:advance()  -- \n
      local pos = s:get_position()
      assert.are.equal(3, pos.line)
    end)
  end)

  describe("at_end()", function()
    it("should return false at start of non-empty source", function()
      local s = scanner_module.Scanner.new("test")
      assert.is_false(s:at_end())
    end)

    it("should return true for empty source", function()
      local s = scanner_module.Scanner.new("")
      assert.is_true(s:at_end())
    end)

    it("should return true after consuming all characters", function()
      local s = scanner_module.Scanner.new("ab")
      s:advance()
      s:advance()
      assert.is_true(s:at_end())
    end)
  end)

  describe("match()", function()
    it("should match and advance on correct character", function()
      local s = scanner_module.Scanner.new("abc")
      assert.is_true(s:match("a"))
      assert.are.equal("b", s:peek())
    end)

    it("should not match on incorrect character", function()
      local s = scanner_module.Scanner.new("abc")
      assert.is_false(s:match("x"))
      assert.are.equal("a", s:peek())
    end)

    it("should return false at end", function()
      local s = scanner_module.Scanner.new("")
      assert.is_false(s:match("a"))
    end)
  end)

  describe("match_string()", function()
    it("should match multi-character string", function()
      local s = scanner_module.Scanner.new("hello world")
      assert.is_true(s:match_string("hello"))
      assert.are.equal(" ", s:peek())
    end)

    it("should not match partial string", function()
      local s = scanner_module.Scanner.new("hel")
      assert.is_false(s:match_string("hello"))
      assert.are.equal("h", s:peek())  -- Position unchanged
    end)

    it("should not match wrong string", function()
      local s = scanner_module.Scanner.new("world")
      assert.is_false(s:match_string("hello"))
    end)

    it("should match at exact end of source", function()
      local s = scanner_module.Scanner.new("end")
      assert.is_true(s:match_string("end"))
      assert.is_true(s:at_end())
    end)
  end)

  describe("match_while()", function()
    it("should match while predicate is true", function()
      local s = scanner_module.Scanner.new("abc123")
      local result = s:match_while(scanner_module.is_alpha)
      assert.are.equal("abc", result)
      assert.are.equal("1", s:peek())
    end)

    it("should return empty string if predicate immediately false", function()
      local s = scanner_module.Scanner.new("123abc")
      local result = s:match_while(scanner_module.is_alpha)
      assert.are.equal("", result)
    end)

    it("should match to end of source", function()
      local s = scanner_module.Scanner.new("abc")
      local result = s:match_while(scanner_module.is_alpha)
      assert.are.equal("abc", result)
      assert.is_true(s:at_end())
    end)
  end)

  describe("mark()/reset_to_mark()", function()
    it("should mark and reset position", function()
      local s = scanner_module.Scanner.new("abcdef")
      s:advance()
      s:advance()
      s:mark()
      s:advance()
      s:advance()
      assert.are.equal("e", s:peek())
      s:reset_to_mark()
      assert.are.equal("c", s:peek())
    end)

    it("should support nested marks", function()
      local s = scanner_module.Scanner.new("abcdef")
      s:mark()  -- at 'a'
      s:advance()
      s:advance()
      s:mark()  -- at 'c'
      s:advance()
      s:advance()
      s:reset_to_mark()  -- back to 'c'
      assert.are.equal("c", s:peek())
      s:reset_to_mark()  -- back to 'a'
      assert.are.equal("a", s:peek())
    end)

    it("should error on reset without mark", function()
      local s = scanner_module.Scanner.new("test")
      assert.has_error(function()
        s:reset_to_mark()
      end, "No mark to reset to")
    end)
  end)

  describe("pop_mark()", function()
    it("should discard mark without resetting", function()
      local s = scanner_module.Scanner.new("abcdef")
      s:mark()
      s:advance()
      s:advance()
      s:pop_mark()
      assert.are.equal("c", s:peek())  -- Still at 'c'
    end)

    it("should error without mark", function()
      local s = scanner_module.Scanner.new("test")
      assert.has_error(function()
        s:pop_mark()
      end, "No mark to pop")
    end)
  end)

  describe("get_lexeme_since_mark()", function()
    it("should return text from mark to current", function()
      local s = scanner_module.Scanner.new("hello world")
      s:mark()
      s:advance()  -- h
      s:advance()  -- e
      s:advance()  -- l
      s:advance()  -- l
      s:advance()  -- o
      assert.are.equal("hello", s:get_lexeme_since_mark())
    end)

    it("should error without mark", function()
      local s = scanner_module.Scanner.new("test")
      assert.has_error(function()
        s:get_lexeme_since_mark()
      end, "No mark to get lexeme from")
    end)

    it("should return empty string if not advanced", function()
      local s = scanner_module.Scanner.new("test")
      s:mark()
      assert.are.equal("", s:get_lexeme_since_mark())
    end)
  end)

  describe("skip_whitespace()", function()
    it("should skip spaces", function()
      local s = scanner_module.Scanner.new("   abc")
      s:skip_whitespace()
      assert.are.equal("a", s:peek())
    end)

    it("should skip tabs", function()
      local s = scanner_module.Scanner.new("\t\tabc")
      s:skip_whitespace()
      assert.are.equal("a", s:peek())
    end)

    it("should not skip newlines", function()
      local s = scanner_module.Scanner.new("  \nabc")
      s:skip_whitespace()
      assert.are.equal("\n", s:peek())
    end)
  end)

  describe("skip_to_eol()", function()
    it("should skip to newline", function()
      local s = scanner_module.Scanner.new("comment here\nnext")
      s:skip_to_eol()
      assert.are.equal("\n", s:peek())
    end)

    it("should skip to end if no newline", function()
      local s = scanner_module.Scanner.new("no newline")
      s:skip_to_eol()
      assert.is_true(s:at_end())
    end)
  end)

  describe("Character classification", function()
    describe("is_alpha()", function()
      it("should identify lowercase letters", function()
        assert.is_true(scanner_module.is_alpha("a"))
        assert.is_true(scanner_module.is_alpha("z"))
        assert.is_true(scanner_module.is_alpha("m"))
      end)

      it("should identify uppercase letters", function()
        assert.is_true(scanner_module.is_alpha("A"))
        assert.is_true(scanner_module.is_alpha("Z"))
        assert.is_true(scanner_module.is_alpha("M"))
      end)

      it("should identify underscore", function()
        assert.is_true(scanner_module.is_alpha("_"))
      end)

      it("should reject digits", function()
        assert.is_false(scanner_module.is_alpha("0"))
        assert.is_false(scanner_module.is_alpha("9"))
      end)

      it("should reject nil", function()
        assert.is_false(scanner_module.is_alpha(nil))
      end)
    end)

    describe("is_digit()", function()
      it("should identify digits", function()
        assert.is_true(scanner_module.is_digit("0"))
        assert.is_true(scanner_module.is_digit("5"))
        assert.is_true(scanner_module.is_digit("9"))
      end)

      it("should reject letters", function()
        assert.is_false(scanner_module.is_digit("a"))
        assert.is_false(scanner_module.is_digit("Z"))
      end)

      it("should reject nil", function()
        assert.is_false(scanner_module.is_digit(nil))
      end)
    end)

    describe("is_alphanumeric()", function()
      it("should accept alpha and digit", function()
        assert.is_true(scanner_module.is_alphanumeric("a"))
        assert.is_true(scanner_module.is_alphanumeric("5"))
        assert.is_true(scanner_module.is_alphanumeric("_"))
      end)

      it("should reject special characters", function()
        assert.is_false(scanner_module.is_alphanumeric("!"))
        assert.is_false(scanner_module.is_alphanumeric(" "))
      end)
    end)

    describe("is_whitespace()", function()
      it("should identify space", function()
        assert.is_true(scanner_module.is_whitespace(" "))
      end)

      it("should identify tab", function()
        assert.is_true(scanner_module.is_whitespace("\t"))
      end)

      it("should not identify newline", function()
        assert.is_false(scanner_module.is_whitespace("\n"))
        assert.is_false(scanner_module.is_whitespace("\r"))
      end)

      it("should reject nil", function()
        assert.is_false(scanner_module.is_whitespace(nil))
      end)
    end)

    describe("is_newline()", function()
      it("should identify LF", function()
        assert.is_true(scanner_module.is_newline("\n"))
      end)

      it("should identify CR", function()
        assert.is_true(scanner_module.is_newline("\r"))
      end)

      it("should not identify space", function()
        assert.is_false(scanner_module.is_newline(" "))
      end)

      it("should reject nil", function()
        assert.is_false(scanner_module.is_newline(nil))
      end)
    end)

    describe("is_identifier_start()", function()
      it("should accept letters and underscore", function()
        assert.is_true(scanner_module.is_identifier_start("a"))
        assert.is_true(scanner_module.is_identifier_start("_"))
        assert.is_true(scanner_module.is_identifier_start("Z"))
      end)

      it("should reject digits", function()
        assert.is_false(scanner_module.is_identifier_start("0"))
      end)
    end)

    describe("is_identifier_char()", function()
      it("should accept alphanumeric", function()
        assert.is_true(scanner_module.is_identifier_char("a"))
        assert.is_true(scanner_module.is_identifier_char("0"))
        assert.is_true(scanner_module.is_identifier_char("_"))
      end)
    end)
  end)

  describe("module metadata", function()
    it("should have _whisker metadata", function()
      assert.is_table(scanner_module._whisker)
      assert.are.equal("script.lexer.scanner", scanner_module._whisker.name)
    end)
  end)
end)
