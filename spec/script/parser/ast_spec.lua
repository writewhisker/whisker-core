-- spec/script/parser/ast_spec.lua
-- Tests for AST node definitions

describe("AST Node Definitions", function()
  local ast_module
  local Node
  local NodeType

  before_each(function()
    -- Clear module cache
    for k in pairs(package.loaded) do
      if k:match("^whisker%.script") then
        package.loaded[k] = nil
      end
    end
    ast_module = require("whisker.script.parser.ast")
    Node = ast_module.Node
    NodeType = ast_module.NodeType
  end)

  describe("NodeType enum", function()
    it("should define all top-level node types", function()
      assert.are.equal("Script", NodeType.Script)
      assert.are.equal("Metadata", NodeType.Metadata)
      assert.are.equal("Include", NodeType.Include)
      assert.are.equal("Passage", NodeType.Passage)
    end)

    it("should define all statement node types", function()
      assert.are.equal("Text", NodeType.Text)
      assert.are.equal("Choice", NodeType.Choice)
      assert.are.equal("Assignment", NodeType.Assignment)
      assert.are.equal("Conditional", NodeType.Conditional)
      assert.are.equal("Divert", NodeType.Divert)
      assert.are.equal("TunnelCall", NodeType.TunnelCall)
      assert.are.equal("TunnelReturn", NodeType.TunnelReturn)
      assert.are.equal("ThreadStart", NodeType.ThreadStart)
    end)

    it("should define all expression node types", function()
      assert.are.equal("BinaryExpr", NodeType.BinaryExpr)
      assert.are.equal("UnaryExpr", NodeType.UnaryExpr)
      assert.are.equal("VariableRef", NodeType.VariableRef)
      assert.are.equal("FunctionCall", NodeType.FunctionCall)
      assert.are.equal("Literal", NodeType.Literal)
      assert.are.equal("ListLiteral", NodeType.ListLiteral)
      assert.are.equal("InlineExpr", NodeType.InlineExpr)
      assert.are.equal("InlineConditional", NodeType.InlineConditional)
    end)

    it("should error on unknown node type access", function()
      assert.has_error(function()
        local _ = NodeType.Unknown
      end)
    end)

    it("should error on modification attempt", function()
      assert.has_error(function()
        NodeType.NewType = "NewType"
      end)
    end)
  end)

  describe("Top-level nodes", function()
    describe("Script node", function()
      it("should create empty script", function()
        local script = Node.script({}, {}, {})
        assert.are.equal("Script", script.type)
        assert.are.same({}, script.metadata)
        assert.are.same({}, script.includes)
        assert.are.same({}, script.passages)
      end)

      it("should create script with passages", function()
        local passage = Node.passage("Start", {}, {})
        local script = Node.script({}, {}, { passage })
        assert.are.equal(1, #script.passages)
        assert.are.equal("Start", script.passages[1].name)
      end)

      it("should include position", function()
        local pos = { line = 1, column = 1, offset = 0 }
        local script = Node.script({}, {}, {}, pos)
        assert.are.equal(1, script.pos.line)
      end)
    end)

    describe("Metadata node", function()
      it("should create metadata with key and value", function()
        local meta = Node.metadata("author", "John Doe")
        assert.are.equal("Metadata", meta.type)
        assert.are.equal("author", meta.key)
        assert.are.equal("John Doe", meta.value)
      end)

      it("should require key", function()
        assert.has_error(function()
          Node.metadata(nil, "value")
        end)
      end)
    end)

    describe("Include node", function()
      it("should create include with path", function()
        local inc = Node.include("other.wsk")
        assert.are.equal("Include", inc.type)
        assert.are.equal("other.wsk", inc.path)
        assert.is_nil(inc.alias)
      end)

      it("should create include with alias", function()
        local inc = Node.include("utils.wsk", "utils")
        assert.are.equal("utils", inc.alias)
      end)
    end)

    describe("Passage node", function()
      it("should create passage with name and body", function()
        local passage = Node.passage("Start", {}, {})
        assert.are.equal("Passage", passage.type)
        assert.are.equal("Start", passage.name)
        assert.are.same({}, passage.tags)
        assert.are.same({}, passage.body)
      end)

      it("should create passage with tags", function()
        local tag = Node.tag("important")
        local passage = Node.passage("Start", { tag }, {})
        assert.are.equal(1, #passage.tags)
      end)

      it("should require name", function()
        assert.has_error(function()
          Node.passage(nil, {}, {})
        end)
      end)

      it("should require body array", function()
        assert.has_error(function()
          Node.passage("Start", {}, nil)
        end)
      end)
    end)
  end)

  describe("Statement nodes", function()
    describe("Text node", function()
      it("should create text with segments", function()
        local text = Node.text({ "Hello, world!" })
        assert.are.equal("Text", text.type)
        assert.are.equal(1, #text.segments)
      end)

      it("should require segments array", function()
        assert.has_error(function()
          Node.text(nil)
        end)
      end)
    end)

    describe("Choice node", function()
      it("should create choice with text", function()
        local text = Node.text({ "Go north" })
        local choice = Node.choice(text)
        assert.are.equal("Choice", choice.type)
        assert.are.equal("Text", choice.text.type)
      end)

      it("should create choice with condition", function()
        local text = Node.text({ "Secret option" })
        local cond = Node.variable_ref("has_key")
        local choice = Node.choice(text, cond)
        assert.are.equal("VariableRef", choice.condition.type)
      end)

      it("should create choice with target", function()
        local text = Node.text({ "Go north" })
        local target = Node.divert("NorthRoom")
        local choice = Node.choice(text, nil, target)
        assert.are.equal("NorthRoom", choice.target.target)
      end)

      it("should track sticky property", function()
        local text = Node.text({ "Option" })
        local choice = Node.choice(text, nil, nil, {}, true)
        assert.is_true(choice.sticky)
      end)
    end)

    describe("Assignment node", function()
      it("should create assignment", function()
        local var = Node.variable_ref("score")
        local value = Node.literal(10, "number")
        local assign = Node.assignment(var, "=", value)
        assert.are.equal("Assignment", assign.type)
        assert.are.equal("=", assign.operator)
      end)

      it("should support compound operators", function()
        local var = Node.variable_ref("score")
        local value = Node.literal(5, "number")
        local assign = Node.assignment(var, "+=", value)
        assert.are.equal("+=", assign.operator)
      end)

      it("should require variable target", function()
        assert.has_error(function()
          Node.assignment(nil, "=", Node.literal(10))
        end)
      end)
    end)

    describe("Conditional node", function()
      it("should create if statement", function()
        local cond = Node.variable_ref("flag")
        local body = { Node.text({ "True branch" }) }
        local node = Node.conditional(cond, body)
        assert.are.equal("Conditional", node.type)
        assert.are.equal(1, #node.then_body)
        assert.are.same({}, node.elif_clauses)
        assert.is_nil(node.else_body)
      end)

      it("should create if-else statement", function()
        local cond = Node.variable_ref("flag")
        local then_body = { Node.text({ "True" }) }
        local else_body = { Node.text({ "False" }) }
        local node = Node.conditional(cond, then_body, {}, else_body)
        assert.are.equal(1, #node.else_body)
      end)

      it("should create if-elif-else chain", function()
        local cond1 = Node.variable_ref("a")
        local cond2 = Node.variable_ref("b")
        local elif = Node.elif_clause(cond2, { Node.text({ "B" }) })
        local node = Node.conditional(cond1, {}, { elif }, {})
        assert.are.equal(1, #node.elif_clauses)
      end)
    end)

    describe("Divert node", function()
      it("should create divert", function()
        local divert = Node.divert("NextPassage")
        assert.are.equal("Divert", divert.type)
        assert.are.equal("NextPassage", divert.target)
        assert.are.same({}, divert.arguments)
      end)

      it("should create divert with arguments", function()
        local arg = Node.literal(42)
        local divert = Node.divert("Target", { arg })
        assert.are.equal(1, #divert.arguments)
      end)
    end)

    describe("Tunnel nodes", function()
      it("should create tunnel call", function()
        local tunnel = Node.tunnel_call("Subroutine")
        assert.are.equal("TunnelCall", tunnel.type)
        assert.are.equal("Subroutine", tunnel.target)
      end)

      it("should create tunnel return", function()
        local ret = Node.tunnel_return()
        assert.are.equal("TunnelReturn", ret.type)
      end)
    end)

    describe("ThreadStart node", function()
      it("should create thread start", function()
        local thread = Node.thread_start("Background")
        assert.are.equal("ThreadStart", thread.type)
        assert.are.equal("Background", thread.target)
      end)
    end)
  end)

  describe("Expression nodes", function()
    describe("BinaryExpr node", function()
      it("should create binary expression", function()
        local left = Node.literal(1)
        local right = Node.literal(2)
        local expr = Node.binary_expr("+", left, right)
        assert.are.equal("BinaryExpr", expr.type)
        assert.are.equal("+", expr.operator)
      end)

      it("should require both operands", function()
        assert.has_error(function()
          Node.binary_expr("+", nil, Node.literal(1))
        end)
        assert.has_error(function()
          Node.binary_expr("+", Node.literal(1), nil)
        end)
      end)
    end)

    describe("UnaryExpr node", function()
      it("should create unary expression", function()
        local operand = Node.variable_ref("flag")
        local expr = Node.unary_expr("!", operand)
        assert.are.equal("UnaryExpr", expr.type)
        assert.are.equal("!", expr.operator)
      end)

      it("should create negation", function()
        local operand = Node.literal(5)
        local expr = Node.unary_expr("-", operand)
        assert.are.equal("-", expr.operator)
      end)
    end)

    describe("VariableRef node", function()
      it("should create variable reference", function()
        local ref = Node.variable_ref("score")
        assert.are.equal("VariableRef", ref.type)
        assert.are.equal("score", ref.name)
        assert.is_nil(ref.index)
      end)

      it("should create indexed variable reference", function()
        local index = Node.literal(0)
        local ref = Node.variable_ref("items", index)
        assert.are.equal("Literal", ref.index.type)
      end)
    end)

    describe("FunctionCall node", function()
      it("should create function call", function()
        local call = Node.function_call("random", {})
        assert.are.equal("FunctionCall", call.type)
        assert.are.equal("random", call.name)
      end)

      it("should create function call with arguments", function()
        local arg1 = Node.literal(1)
        local arg2 = Node.literal(10)
        local call = Node.function_call("random", { arg1, arg2 })
        assert.are.equal(2, #call.arguments)
      end)
    end)

    describe("Literal node", function()
      it("should create number literal", function()
        local lit = Node.literal(42, "number")
        assert.are.equal("Literal", lit.type)
        assert.are.equal(42, lit.value)
        assert.are.equal("number", lit.literal_type)
      end)

      it("should create string literal", function()
        local lit = Node.literal("hello", "string")
        assert.are.equal("hello", lit.value)
        assert.are.equal("string", lit.literal_type)
      end)

      it("should create boolean literal", function()
        local lit = Node.literal(true, "boolean")
        assert.is_true(lit.value)
        assert.are.equal("boolean", lit.literal_type)
      end)

      it("should create null literal", function()
        local lit = Node.literal(nil, "null")
        assert.is_nil(lit.value)
        assert.are.equal("null", lit.literal_type)
      end)

      it("should infer type from value", function()
        local lit = Node.literal(3.14)
        assert.are.equal("number", lit.literal_type)
      end)
    end)

    describe("ListLiteral node", function()
      it("should create empty list", function()
        local list = Node.list_literal({})
        assert.are.equal("ListLiteral", list.type)
        assert.are.equal(0, #list.elements)
      end)

      it("should create list with elements", function()
        local elem1 = Node.literal(1)
        local elem2 = Node.literal(2)
        local list = Node.list_literal({ elem1, elem2 })
        assert.are.equal(2, #list.elements)
      end)
    end)

    describe("InlineExpr node", function()
      it("should create inline expression", function()
        local expr = Node.variable_ref("name")
        local inline = Node.inline_expr(expr)
        assert.are.equal("InlineExpr", inline.type)
        assert.are.equal("VariableRef", inline.expression.type)
      end)
    end)

    describe("InlineConditional node", function()
      it("should create inline conditional", function()
        local cond = Node.variable_ref("flag")
        local then_val = Node.literal("yes")
        local else_val = Node.literal("no")
        local node = Node.inline_conditional(cond, then_val, else_val)
        assert.are.equal("InlineConditional", node.type)
        assert.is_not_nil(node.condition)
        assert.is_not_nil(node.then_value)
        assert.is_not_nil(node.else_value)
      end)
    end)
  end)

  describe("Helper functions", function()
    describe("is_node", function()
      it("should return true for AST nodes", function()
        local node = Node.literal(42)
        assert.is_true(ast_module.is_node(node))
      end)

      it("should return false for non-nodes", function()
        assert.is_false(ast_module.is_node(nil))
        assert.is_false(ast_module.is_node(42))
        assert.is_false(ast_module.is_node("string"))
        assert.is_false(ast_module.is_node({}))
        assert.is_false(ast_module.is_node({ type = "Invalid" }))
      end)
    end)

    describe("is_type", function()
      it("should check node type", function()
        local node = Node.literal(42)
        assert.is_true(ast_module.is_type(node, "Literal"))
        assert.is_false(ast_module.is_type(node, "BinaryExpr"))
      end)
    end)

    describe("is_expression", function()
      it("should identify expression nodes", function()
        assert.is_true(ast_module.is_expression(Node.literal(42)))
        assert.is_true(ast_module.is_expression(Node.variable_ref("x")))
        assert.is_true(ast_module.is_expression(Node.binary_expr("+", Node.literal(1), Node.literal(2))))
      end)

      it("should reject non-expression nodes", function()
        assert.is_false(ast_module.is_expression(Node.text({ "hello" })))
        assert.is_false(ast_module.is_expression(Node.passage("Start", {}, {})))
      end)
    end)

    describe("is_statement", function()
      it("should identify statement nodes", function()
        assert.is_true(ast_module.is_statement(Node.text({ "hello" })))
        assert.is_true(ast_module.is_statement(Node.divert("Target")))
        assert.is_true(ast_module.is_statement(Node.assignment(
          Node.variable_ref("x"), "=", Node.literal(1))))
      end)

      it("should reject non-statement nodes", function()
        assert.is_false(ast_module.is_statement(Node.literal(42)))
        assert.is_false(ast_module.is_statement(Node.passage("Start", {}, {})))
      end)
    end)

    describe("get_span", function()
      it("should return span for node with position", function()
        local pos = { line = 1, column = 1, offset = 0 }
        local node = Node.literal(42, "number", pos)
        local span = ast_module.get_span(node)
        assert.is_not_nil(span)
        assert.are.equal(1, span.start.line)
      end)

      it("should return nil for node without position", function()
        local node = Node.literal(42)
        local span = ast_module.get_span(node)
        assert.is_nil(span)
      end)
    end)

    describe("with_position", function()
      it("should create node copy with new position", function()
        local node = Node.literal(42, "number")
        local pos = { line = 5, column = 10, offset = 50 }
        local new_node = ast_module.with_position(node, pos)
        assert.are.equal(42, new_node.value)
        assert.are.equal(5, new_node.pos.line)
        assert.is_nil(node.pos)  -- Original unchanged
      end)
    end)
  end)

  describe("Node immutability", function()
    it("should prevent modification of nodes", function()
      local node = Node.literal(42)
      assert.has_error(function()
        node.value = 100
      end)
    end)

    it("should prevent adding new fields", function()
      local node = Node.literal(42)
      assert.has_error(function()
        node.newField = "test"
      end)
    end)
  end)

  describe("Tag node", function()
    it("should create tag with name", function()
      local tag = Node.tag("important")
      assert.are.equal("Tag", tag.type)
      assert.are.equal("important", tag.name)
      assert.is_nil(tag.value)
    end)

    it("should create tag with value", function()
      local tag = Node.tag("priority", 1)
      assert.are.equal(1, tag.value)
    end)
  end)
end)
