-- Whisker Script Compiler
-- Generates Lua code from AST
--
-- lib/whisker/script/compiler.lua

local AST = require("whisker.script.ast")

--------------------------------------------------------------------------------
-- Compiler Class
--------------------------------------------------------------------------------

local Compiler = {}
Compiler.__index = Compiler

--- Create a new compiler
---@param options table|nil Compiler options
---@return Compiler
function Compiler.new(options)
  local self = setmetatable({}, Compiler)

  self.options = options or {}
  self.output = {}
  self.indent_level = 0

  -- Track variables for optimization
  self.variables = {}

  -- Track passages for validation
  self.passages = {}

  return self
end

--------------------------------------------------------------------------------
-- Output Helpers
--------------------------------------------------------------------------------

--- Emit raw code
---@param code string Code to emit
function Compiler:emit(code)
  table.insert(self.output, code)
end

--- Emit a line of code with indentation
---@param code string Code to emit
function Compiler:emit_line(code)
  local indent = string.rep("  ", self.indent_level)
  table.insert(self.output, indent .. code .. "\n")
end

--- Emit an empty line
function Compiler:emit_blank()
  table.insert(self.output, "\n")
end

--- Increase indentation
function Compiler:indent()
  self.indent_level = self.indent_level + 1
end

--- Decrease indentation
function Compiler:dedent()
  self.indent_level = math.max(0, self.indent_level - 1)
end

--- Get the compiled output
---@return string Lua code
function Compiler:get_output()
  return table.concat(self.output)
end

--------------------------------------------------------------------------------
-- String Escaping
--------------------------------------------------------------------------------

--- Escape a string for Lua
---@param str string String to escape
---@return string Escaped string
function Compiler:escape_string(str)
  if type(str) ~= "string" then
    return tostring(str)
  end

  return str
    :gsub("\\", "\\\\")
    :gsub("\n", "\\n")
    :gsub("\r", "\\r")
    :gsub("\t", "\\t")
    :gsub('"', '\\"')
end

--- Quote a string for Lua
---@param str string String to quote
---@return string Quoted string
function Compiler:quote_string(str)
  return '"' .. self:escape_string(str) .. '"'
end

--------------------------------------------------------------------------------
-- Main Compilation
--------------------------------------------------------------------------------

--- Compile an AST to Lua code
---@param ast table Program AST node
---@return string Lua code
function Compiler:compile(ast)
  self.output = {}
  self.indent_level = 0
  self.variables = {}
  self.passages = {}

  -- Collect passage names first
  if ast.type == "program" then
    for _, passage in ipairs(ast.passages or {}) do
      self.passages[passage.name] = true
    end
  end

  -- Generate code
  self:visit_program(ast)

  return self:get_output()
end

--------------------------------------------------------------------------------
-- Visitor Methods
--------------------------------------------------------------------------------

--- Visit program node
---@param node table Program AST node
function Compiler:visit_program(node)
  -- Header
  self:emit_line("-- Generated by Whisker Script Compiler")
  self:emit_line("-- Do not edit this file directly")
  self:emit_blank()

  -- Module setup
  self:emit_line("local story = {}")
  self:emit_line("story.passages = {}")
  self:emit_line("story.start_passage = nil")
  self:emit_blank()

  -- State helper
  self:emit_line("-- State access helper")
  self:emit_line("local function get_var(state, name)")
  self:indent()
  self:emit_line("return state:get(name)")
  self:dedent()
  self:emit_line("end")
  self:emit_blank()

  self:emit_line("local function set_var(state, name, value)")
  self:indent()
  self:emit_line("state:set(name, value)")
  self:dedent()
  self:emit_line("end")
  self:emit_blank()

  -- Generate passages
  for i, passage in ipairs(node.passages or {}) do
    self:visit_passage(passage)

    -- Set first passage as start
    if i == 1 then
      self:emit_line("story.start_passage = " .. self:quote_string(passage.name))
      self:emit_blank()
    end
  end

  -- Return module
  self:emit_line("return story")
end

--- Visit passage node
---@param node table Passage AST node
function Compiler:visit_passage(node)
  local name = node.name or "unnamed"

  self:emit_line("story.passages[" .. self:quote_string(name) .. "] = function(state)")
  self:indent()

  self:emit_line("local content = {}")
  self:emit_line("local choices = {}")
  self:emit_blank()

  -- Generate content
  for _, elem in ipairs(node.content or {}) do
    self:visit_content_element(elem)
  end

  -- Return passage data
  self:emit_blank()
  self:emit_line("return {")
  self:indent()
  self:emit_line("content = table.concat(content),")
  self:emit_line("choices = choices")
  self:dedent()
  self:emit_line("}")

  self:dedent()
  self:emit_line("end")
  self:emit_blank()
end

--- Visit a content element
---@param node table Content element AST node
function Compiler:visit_content_element(node)
  if node.type == "text" then
    self:visit_text(node)
  elseif node.type == "choice" then
    self:visit_choice(node)
  elseif node.type == "conditional" then
    self:visit_conditional(node)
  elseif node.type == "assignment" then
    self:visit_assignment(node)
  elseif node.type == "lua_block" then
    self:visit_lua_block(node)
  end
end

--- Visit text node
---@param node table Text AST node
function Compiler:visit_text(node)
  local content = node.content

  if type(content) == "string" then
    -- Simple string
    self:emit_line("table.insert(content, " .. self:quote_string(content) .. ")")
    self:emit_line('table.insert(content, "\\n")')
  elseif type(content) == "table" and content.type == "interpolation" then
    -- Interpolated text
    self:emit("  table.insert(content, ")
    self:emit_interpolation(content)
    self:emit(")\n")
    self:emit_line('table.insert(content, "\\n")')
  end
end

--- Emit interpolation expression
---@param node table Interpolation AST node
function Compiler:emit_interpolation(node)
  local parts = {}

  for _, part in ipairs(node.parts or {}) do
    if type(part) == "string" then
      table.insert(parts, self:quote_string(part))
    elseif type(part) == "table" and part.type == "variable" then
      table.insert(parts, "tostring(get_var(state, " .. self:quote_string(part.name) .. ") or \"\")")
    end
  end

  if #parts == 0 then
    self:emit('""')
  elseif #parts == 1 then
    self:emit(parts[1])
  else
    self:emit("(" .. table.concat(parts, " .. ") .. ")")
  end
end

--- Visit choice node
---@param node table Choice AST node
function Compiler:visit_choice(node)
  local text = node.text
  local target = node.target or "unknown"
  local condition = node.condition

  -- Generate text expression
  local text_expr
  if type(text) == "string" then
    text_expr = self:quote_string(text)
  elseif type(text) == "table" and text.type == "interpolation" then
    local parts = {}
    for _, part in ipairs(text.parts or {}) do
      if type(part) == "string" then
        table.insert(parts, self:quote_string(part))
      elseif type(part) == "table" and part.type == "variable" then
        table.insert(parts, "tostring(get_var(state, " .. self:quote_string(part.name) .. ") or \"\")")
      end
    end
    text_expr = "(" .. table.concat(parts, " .. ") .. ")"
  else
    text_expr = '""'
  end

  if condition then
    -- Conditional choice
    self:emit_line("if " .. self:compile_expression(condition) .. " then")
    self:indent()
    self:emit_line("table.insert(choices, {")
    self:indent()
    self:emit_line("text = " .. text_expr .. ",")
    self:emit_line("target = " .. self:quote_string(target))
    self:dedent()
    self:emit_line("})")
    self:dedent()
    self:emit_line("end")
  else
    -- Unconditional choice
    self:emit_line("table.insert(choices, {")
    self:indent()
    self:emit_line("text = " .. text_expr .. ",")
    self:emit_line("target = " .. self:quote_string(target))
    self:dedent()
    self:emit_line("})")
  end
end

--- Visit conditional node
---@param node table Conditional AST node
function Compiler:visit_conditional(node)
  self:emit_line("if " .. self:compile_expression(node.condition) .. " then")
  self:indent()

  for _, elem in ipairs(node.then_content or {}) do
    self:visit_content_element(elem)
  end

  self:dedent()
  self:emit_line("end")
end

--- Visit assignment node
---@param node table Assignment AST node
function Compiler:visit_assignment(node)
  local name = node.variable
  local op = node.operator
  local value_expr = self:compile_expression(node.value)

  if op == "=" then
    self:emit_line("set_var(state, " .. self:quote_string(name) .. ", " .. value_expr .. ")")
  elseif op == "+=" then
    self:emit_line("set_var(state, " .. self:quote_string(name) .. ", (get_var(state, " ..
                   self:quote_string(name) .. ") or 0) + " .. value_expr .. ")")
  elseif op == "-=" then
    self:emit_line("set_var(state, " .. self:quote_string(name) .. ", (get_var(state, " ..
                   self:quote_string(name) .. ") or 0) - " .. value_expr .. ")")
  end
end

--- Visit Lua block node
---@param node table LuaBlock AST node
function Compiler:visit_lua_block(node)
  local code = node.code or ""

  -- Check if it's an expression assignment
  if code:match("^%s*$") then
    return  -- Empty block
  end

  self:emit_line("-- Embedded Lua")
  -- Emit the Lua code directly (with proper indentation)
  for line in code:gmatch("[^\n]+") do
    self:emit_line(line:gsub("^%s+", ""))
  end
end

--------------------------------------------------------------------------------
-- Expression Compilation
--------------------------------------------------------------------------------

--- Compile an expression to Lua code
---@param node table Expression AST node
---@return string Lua expression
function Compiler:compile_expression(node)
  if not node or not node.type then
    return "nil"
  end

  if node.type == "literal" then
    return self:compile_literal(node)
  elseif node.type == "variable" then
    return self:compile_variable(node)
  elseif node.type == "binary_op" then
    return self:compile_binary_op(node)
  elseif node.type == "unary_op" then
    return self:compile_unary_op(node)
  else
    return "nil"
  end
end

--- Compile a literal
---@param node table Literal AST node
---@return string Lua expression
function Compiler:compile_literal(node)
  local value = node.value

  if value == nil then
    return "nil"
  elseif type(value) == "boolean" then
    return tostring(value)
  elseif type(value) == "number" then
    return tostring(value)
  elseif type(value) == "string" then
    return self:quote_string(value)
  else
    return "nil"
  end
end

--- Compile a variable reference
---@param node table Variable AST node
---@return string Lua expression
function Compiler:compile_variable(node)
  return "get_var(state, " .. self:quote_string(node.name) .. ")"
end

--- Compile a binary operation
---@param node table BinaryOp AST node
---@return string Lua expression
function Compiler:compile_binary_op(node)
  local left = self:compile_expression(node.left)
  local right = self:compile_expression(node.right)
  local op = node.operator

  -- Convert operators to Lua equivalents
  local lua_op
  if op == "&&" then
    lua_op = "and"
  elseif op == "||" then
    lua_op = "or"
  elseif op == "==" then
    lua_op = "=="
  elseif op == "!=" then
    lua_op = "~="
  else
    lua_op = op  -- <, >, <=, >= are the same
  end

  return "(" .. left .. " " .. lua_op .. " " .. right .. ")"
end

--- Compile a unary operation
---@param node table UnaryOp AST node
---@return string Lua expression
function Compiler:compile_unary_op(node)
  local operand = self:compile_expression(node.operand)

  if node.operator == "!" then
    return "(not " .. operand .. ")"
  else
    return operand
  end
end

--------------------------------------------------------------------------------
-- Optimization (Stage 16)
--------------------------------------------------------------------------------

--- Apply optimizations to the AST before compilation
---@param ast table Program AST node
---@return table Optimized AST
function Compiler:optimize(ast)
  -- Constant folding
  ast = self:fold_constants(ast)

  -- Dead code elimination (conditionals with constant false)
  ast = self:eliminate_dead_code(ast)

  return ast
end

--- Fold constant expressions
---@param node table AST node
---@return table Modified node
function Compiler:fold_constants(node)
  if not node or type(node) ~= "table" then
    return node
  end

  -- Recursively fold children first
  if node.type == "program" then
    for i, passage in ipairs(node.passages or {}) do
      node.passages[i] = self:fold_constants(passage)
    end
  elseif node.type == "passage" then
    for i, elem in ipairs(node.content or {}) do
      node.content[i] = self:fold_constants(elem)
    end
  elseif node.type == "conditional" then
    node.condition = self:fold_constants(node.condition)
    for i, elem in ipairs(node.then_content or {}) do
      node.then_content[i] = self:fold_constants(elem)
    end
  elseif node.type == "choice" then
    if node.condition then
      node.condition = self:fold_constants(node.condition)
    end
  elseif node.type == "assignment" then
    node.value = self:fold_constants(node.value)
  elseif node.type == "binary_op" then
    node.left = self:fold_constants(node.left)
    node.right = self:fold_constants(node.right)

    -- Try to fold if both operands are literals
    if node.left.type == "literal" and node.right.type == "literal" then
      local result = self:evaluate_binary_op(node.operator, node.left.value, node.right.value)
      if result ~= nil then
        return AST.Literal(result, node.metadata)
      end
    end
  elseif node.type == "unary_op" then
    node.operand = self:fold_constants(node.operand)

    -- Try to fold if operand is literal
    if node.operand.type == "literal" and node.operator == "!" then
      return AST.Literal(not node.operand.value, node.metadata)
    end
  end

  return node
end

--- Evaluate a binary operation on constants
---@param op string Operator
---@param left any Left value
---@param right any Right value
---@return any|nil Result or nil if can't evaluate
function Compiler:evaluate_binary_op(op, left, right)
  if op == "&&" then
    return left and right
  elseif op == "||" then
    return left or right
  elseif op == "==" then
    return left == right
  elseif op == "!=" then
    return left ~= right
  elseif op == "<" and type(left) == "number" and type(right) == "number" then
    return left < right
  elseif op == ">" and type(left) == "number" and type(right) == "number" then
    return left > right
  elseif op == "<=" and type(left) == "number" and type(right) == "number" then
    return left <= right
  elseif op == ">=" and type(left) == "number" and type(right) == "number" then
    return left >= right
  end

  return nil
end

--- Eliminate dead code (conditionals with constant false)
---@param node table AST node
---@return table Modified node
function Compiler:eliminate_dead_code(node)
  if not node or type(node) ~= "table" then
    return node
  end

  if node.type == "program" then
    for i, passage in ipairs(node.passages or {}) do
      node.passages[i] = self:eliminate_dead_code(passage)
    end
  elseif node.type == "passage" then
    local new_content = {}
    for _, elem in ipairs(node.content or {}) do
      elem = self:eliminate_dead_code(elem)
      -- Skip conditionals that are always false
      if elem.type == "conditional" and
         elem.condition.type == "literal" and
         not elem.condition.value then
        -- Skip this conditional (dead code)
      else
        table.insert(new_content, elem)
      end
    end
    node.content = new_content
  elseif node.type == "conditional" then
    for i, elem in ipairs(node.then_content or {}) do
      node.then_content[i] = self:eliminate_dead_code(elem)
    end
  end

  return node
end

--------------------------------------------------------------------------------
-- Module Export
--------------------------------------------------------------------------------

return Compiler
